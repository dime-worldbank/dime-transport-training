<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Session 3 - Spatial Data Operations</title>
    <meta charset="utf-8" />
    <meta name="author" content="Luiza Andrade, Rob Marty, Rony Rodriguez-Ramirez, Luis Eduardo San Martin, Leonardo Viotti" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link href="libs/panelset/panelset.css" rel="stylesheet" />
    <script src="libs/panelset/panelset.js"></script>
    <script type="application/json" id="xaringanExtra-editable-docid">{"id":"xe8099987b4648d5ad038eec66c6b5e2","expires":14}</script>
    <script src="libs/himalaya/himalaya.js"></script>
    <script src="libs/js-cookie/js.cookie.js"></script>
    <link href="libs/editable/editable.css" rel="stylesheet" />
    <script src="libs/editable/editable.js"></script>
    <script src="libs/clipboard/clipboard.min.js"></script>
    <link href="libs/xaringanExtra-clipboard/xaringanExtra-clipboard.css" rel="stylesheet" />
    <script src="libs/xaringanExtra-clipboard/xaringanExtra-clipboard.js"></script>
    <script>window.xaringanExtraClipboard(null, {"button":"Copy Code","success":"Copied!","error":"Press Ctrl+C to Copy"})</script>
    <script>window.xaringanExtraClipboard(null, {"button":"<i class=\"fa fa-clipboard\"><\/i>","success":"<i class=\"fa fa-check\" style=\"color: #90BE6D\"><\/i>","error":"<i class=\"fa fa-times-circle\" style=\"color: #F94144\"><\/i>"})</script>
    <link href="libs/font-awesome/css/all.css" rel="stylesheet" />
    <link href="libs/font-awesome/css/v4-shims.css" rel="stylesheet" />
    <link href="libs/countdown/countdown.css" rel="stylesheet" />
    <script src="libs/countdown/countdown.js"></script>
    <link rel="stylesheet" href="libs/remark-css/default.css" type="text/css" />
    <link rel="stylesheet" href="libs/remark-css/metropolis.css" type="text/css" />
    <link rel="stylesheet" href="libs/remark-css/metropolis-fonts.css" type="text/css" />
    <link rel="stylesheet" href="libs/remark-css/custom.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# Session 3 - Spatial Data Operations
]
.subtitle[
## <a href="https://github.com/worldbank">GIS for Transport</a>
]
.author[
### Luiza Andrade, Rob Marty, Rony Rodriguez-Ramirez, Luis Eduardo San Martin, Leonardo Viotti
]
.date[
### The World Bank – DIME | <a href="https://github.com/worldbank">WB Github</a> <br> April 2024
]

---




# Table of contents

.large[
1. Spatial operations applied on one dataset
2. Spatial operations applied on multiple datasets
]

---

# Setup

1. Copy/paste the following code into a new RStudio script, __replacing "YOURFOLDERPATHHERE" with the folder within which you'll place this R project__:

```r
library(usethis)
use_course(
  url = "https://github.com/worldbank/dime-r-training/archive/main.zip",
  destdir = "YOURFOLDERPATHHERE"
)
```

2\. In the console, type in the requisite number to delete the .zip file (we don't need it anymore).

3\. A new RStudio environment will open. Use this for the session today.

---

# Setup

Install new packages

```r
install.packages(c("sf",
                   "leaflet",
                   "geosphere"),
                 dependencies = TRUE)
```

---

# Setup

And load them

```r
library(here)
library(tidyverse)
library(sf)        # Simple features
library(leaflet)   # Interactive map
library(geosphere) # Great circle distances
```

---

# Load &amp; prep polygon of Nairobi


```r
country_sf &lt;- st_read(here("DataWork", 
                           "DataSets", 
                           "Final", 
                           "country.geojson"))
```

```
## Reading layer `country' from data source 
##   `/Users/robmarty/Documents/Github/gis-transport-training/DataWork/DataSets/Final/country.geojson' 
##   using driver `GeoJSON'
## Simple feature collection with 300 features and 13 fields
## Geometry type: MULTIPOLYGON
## Dimension:     XY
## Bounding box:  xmin: 33.90959 ymin: -4.720417 xmax: 41.92622 ymax: 5.061166
## Geodetic CRS:  WGS 84
```

```r
city_sf &lt;- country_sf %&gt;% 
  filter(NAME_1 == "Nairobi")
```

---

# Load and prep polyline of roads
Read in the roads dataset using `st_read` function from the `sf` package into R


```r
roads_sf &lt;- st_read(here("DataWork", 
                         "DataSets", 
                         "Final", 
                         "roads.geojson"))
```

```
## Reading layer `roads' from data source 
##   `/Users/robmarty/Documents/Github/gis-transport-training/DataWork/DataSets/Final/roads.geojson' 
##   using driver `GeoJSON'
## Simple feature collection with 3352 features and 3 fields
## Geometry type: MULTILINESTRING
## Dimension:     XY
## Bounding box:  xmin: 36.68034 ymin: -1.428946 xmax: 37.07664 ymax: -1.162558
## Geodetic CRS:  WGS 84
```

---

# Load and prep spatial points data of schools
Read in the schools data dataset using `read.csv` function from the `dplyr` package into R


```r
schools_df &lt;- read_csv(here("DataWork",
                "DataSets",
                "Final",
                "schools.csv"))
```

```
## Rows: 3549 Columns: 5
## ── Column specification ────────────────────────────────────────────────────────
## Delimiter: ","
## chr (2): name, amenity
## dbl (3): osm_id, longitude, latitude
## 
## ℹ Use `spec()` to retrieve the full column specification for this data.
## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
```

---

# Load and prep spatial points data of schools
Convert the __schools_df__ into a spatial dataframe using the `st_as_sf`


```r
schools_sf &lt;- st_as_sf(schools_df, 
                       coords = c("longitude", "latitude"),
                       crs = 4326)
```
---

# Spatial operations applied on single dataset

* `st_transform`: Transform CRS
* `st_buffer`: Buffer point/line/polygon
* `st_combine`: Dissolve by attribute
* `st_convex_hull `: Create convex hull
* `st_centroid`: Create new sf object that uses the centroid
* `st_drop_geometry`: Drop geometry; convert from sf to dataframe
* `st_coordinates`: Get matrix of coordinates
* `st_bbox`: Get bounding box

---

# Transform CRS

The schools dataset is currently in a geographic CRS (WGS84), where the units are in decimal degrees. We'll tranform the CRS to a projected CRS ([EPSG:32632](https://epsg.io/32632)), and where the units will be in meters.

__Note that coordinate values are large!__ Values are large because units are in meters. Large coordinate values suggest projected CRS; latitude is between -90 and 90 and longitude is between -180 and 180.


```r
schools_utm_sf &lt;- st_transform(schools_sf, 32632)

schools_utm_sf$geometry %&gt;% head(2) %&gt;% print()
```

```
## Geometry set for 2 features 
## Geometry type: POINT
## Dimension:     XY
## Bounding box:  xmin: 3722217 ymin: -158522.3 xmax: 3723051 ymax: -157537.6
## Projected CRS: WGS 84 / UTM zone 32N
```

```
## POINT (3723051 -158522.3)
```

```
## POINT (3722217 -157537.6)
```

---

# Dissolve by an attribute

Below we have the second administrative regions. Using this dataset, let's create a new object at the first administrative region level. We are going to use `st_combine` function


```r
country_1_sf &lt;- country_sf %&gt;%
  group_by(NAME_1) %&gt;%
  summarise(geometry = st_combine(geometry)) %&gt;%
  ungroup()

ggplot() +
  geom_sf(data = country_1_sf)
```

&lt;img src="03-spatial-data-operations_files/figure-html/unnamed-chunk-9-1.png" width="30%" style="display: block; margin: auto;" /&gt;

---

# Buffer

We have the points of schools. Now we create a 1km buffer around schools.


```r
schools_1km_sf &lt;- schools_sf %&gt;%
  st_buffer(dist = 1000) # Units are in meters. Thanks s2!

ggplot() +
  geom_sf(data = schools_1km_sf)
```

&lt;img src="03-spatial-data-operations_files/figure-html/unnamed-chunk-10-1.png" width="50%" style="display: block; margin: auto;" /&gt;

---

# Exercise

.exercise[

**Exercise:** Create a polyline of all trunk roads, and buffer the poyline by 10 meters. In `roads_sf`, the `highway` variable notes road types.

]

<div class="countdown" id="timer_d77dfa43" data-update-every="1" tabindex="0" style="bottom:0;left:0;font-size:2em;">
<div class="countdown-controls"><button class="countdown-bump-down">&minus;</button><button class="countdown-bump-up">&plus;</button></div>
<code class="countdown-time"><span class="countdown-digits minutes">02</span><span class="countdown-digits colon">:</span><span class="countdown-digits seconds">00</span></code>
</div>

--

.solution[

**Solution**: 

```r
roads_sf %&gt;%
  filter(highway == "trunk") %&gt;%
  summarise(geometry = st_combine(geometry)) %&gt;%
  st_buffer(dist = 10)
```

```
## Simple feature collection with 1 feature and 0 fields
## Geometry type: MULTIPOLYGON
## Dimension:     XY
## Bounding box:  xmin: 36.68359 ymin: -1.386576 xmax: 37.07692 ymax: -1.204784
## Geodetic CRS:  WGS 84
##                         geometry
## 1 MULTIPOLYGON (((36.76646 -1...
```

]

---

# Convex Hull

__Simple definition:__ Get the outer-most coordinates of a shape and connect-the-dots.

__Formal definition:__ A convex hull of a shape the smallest "convex set" that contains it. (A [convex set](https://en.wikipedia.org/wiki/Convex_set) is where a straight line can be drawn anywhere in the space and the space fully contains the line).

.pull-left[
__Convex__

![Convex](img/Convex_polygon_illustration1.svg.png)
]

.pull-right[
__Not convex__

![Not Convex](img/220px-Convex_polygon_illustration2.svg.png)
]

__Source:__ [Wikipedia](https://en.wikipedia.org/wiki/Convex_set)

---

# Convex hull

In the below example, we create a conex hull around schools; creating a polygon that includes all schools.

__Incorrect attempt__


```r
schools_chull1_sf &lt;- schools_sf %&gt;%
  st_convex_hull()

nrow(schools_chull1_sf)
```

```
## [1] 3549
```

---

# Convex hull

__Correct__


```r
schools_chull2_sf &lt;- schools_sf %&gt;%
  summarise(geometry = st_combine(geometry)) %&gt;%
  st_convex_hull()

ggplot() +
  geom_sf(data = schools_chull2_sf) +
  geom_sf(data = schools_sf, color = "red")
```

&lt;img src="03-spatial-data-operations_files/figure-html/unnamed-chunk-13-1.png" width="40%" style="display: block; margin: auto;" /&gt;

---

# Determine centroid

Sometimes we want to represent a polygon or polyline as a single point. For this, we can compute the centroid (ie, geographic center) of a polygon/polyline.

.center[
![Centroid](img/220px-Triangle.Centroid.svg.png)
]

__Source:__ [Wikipedia](https://en.wikipedia.org/wiki/Centroid)

---

# Determine centroid

Determine centroid of second administrative regions


```r
country_c_sf &lt;- st_centroid(country_sf)
```

```
## Warning: st_centroid assumes attributes are constant over geometries
```

```r
ggplot() +
  geom_sf(data = country_c_sf)
```

&lt;img src="03-spatial-data-operations_files/figure-html/unnamed-chunk-14-1.png" width="40%" style="display: block; margin: auto;" /&gt;

---

# Remove geometry

__Incorrect approach__


```r
city_sf %&gt;% 
  select(-geometry) %&gt;%
  head()
```

```
## Simple feature collection with 6 features and 13 fields
## Geometry type: MULTIPOLYGON
## Dimension:     XY
## Bounding box:  xmin: 36.67803 ymin: -1.370704 xmax: 36.99025 ymax: -1.234921
## Geodetic CRS:  WGS 84
##        GID_2 GID_0 COUNTRY    GID_1  NAME_1 NL_NAME_1           NAME_2
## 1 KEN.30.1_1   KEN   Kenya KEN.30_1 Nairobi      &lt;NA&gt;  Dagoretti North
## 2 KEN.30.2_1   KEN   Kenya KEN.30_1 Nairobi      &lt;NA&gt;  Dagoretti South
## 3 KEN.30.3_1   KEN   Kenya KEN.30_1 Nairobi      &lt;NA&gt; Embakasi Central
## 4 KEN.30.4_1   KEN   Kenya KEN.30_1 Nairobi      &lt;NA&gt;    Embakasi East
## 5 KEN.30.5_1   KEN   Kenya KEN.30_1 Nairobi      &lt;NA&gt;   Embakasi North
## 6 KEN.30.6_1   KEN   Kenya KEN.30_1 Nairobi      &lt;NA&gt;   Embakasi South
##   VARNAME_2 NL_NAME_2       TYPE_2    ENGTYPE_2 CC_2 HASC_2
## 1      &lt;NA&gt;      &lt;NA&gt; Constituency Constituency  275   &lt;NA&gt;
## 2      &lt;NA&gt;      &lt;NA&gt; Constituency Constituency  276   &lt;NA&gt;
## 3      &lt;NA&gt;      &lt;NA&gt; Constituency Constituency  284   &lt;NA&gt;
## 4      &lt;NA&gt;      &lt;NA&gt; Constituency Constituency  285   &lt;NA&gt;
## 5      &lt;NA&gt;      &lt;NA&gt; Constituency Constituency  283   &lt;NA&gt;
## 6      &lt;NA&gt;      &lt;NA&gt; Constituency Constituency  282   &lt;NA&gt;
##                         geometry
## 1 MULTIPOLYGON (((36.76082 -1...
## 2 MULTIPOLYGON (((36.75381 -1...
## 3 MULTIPOLYGON (((36.9181 -1....
## 4 MULTIPOLYGON (((36.97557 -1...
## 5 MULTIPOLYGON (((36.89368 -1...
## 6 MULTIPOLYGON (((36.9065 -1....
```

---

# Remove geometry

__Correct__


```r
city_sf %&gt;% 
  st_drop_geometry() %&gt;%
  head()
```

```
##        GID_2 GID_0 COUNTRY    GID_1  NAME_1 NL_NAME_1           NAME_2
## 1 KEN.30.1_1   KEN   Kenya KEN.30_1 Nairobi      &lt;NA&gt;  Dagoretti North
## 2 KEN.30.2_1   KEN   Kenya KEN.30_1 Nairobi      &lt;NA&gt;  Dagoretti South
## 3 KEN.30.3_1   KEN   Kenya KEN.30_1 Nairobi      &lt;NA&gt; Embakasi Central
## 4 KEN.30.4_1   KEN   Kenya KEN.30_1 Nairobi      &lt;NA&gt;    Embakasi East
## 5 KEN.30.5_1   KEN   Kenya KEN.30_1 Nairobi      &lt;NA&gt;   Embakasi North
## 6 KEN.30.6_1   KEN   Kenya KEN.30_1 Nairobi      &lt;NA&gt;   Embakasi South
##   VARNAME_2 NL_NAME_2       TYPE_2    ENGTYPE_2 CC_2 HASC_2
## 1      &lt;NA&gt;      &lt;NA&gt; Constituency Constituency  275   &lt;NA&gt;
## 2      &lt;NA&gt;      &lt;NA&gt; Constituency Constituency  276   &lt;NA&gt;
## 3      &lt;NA&gt;      &lt;NA&gt; Constituency Constituency  284   &lt;NA&gt;
## 4      &lt;NA&gt;      &lt;NA&gt; Constituency Constituency  285   &lt;NA&gt;
## 5      &lt;NA&gt;      &lt;NA&gt; Constituency Constituency  283   &lt;NA&gt;
## 6      &lt;NA&gt;      &lt;NA&gt; Constituency Constituency  282   &lt;NA&gt;
```

---

# Grab coordinates

Create a matrix of coordinates


```r
schools_sf %&gt;% 
  st_coordinates() %&gt;%
  head()
```

```
##             X         Y
## [1,] 36.80406 -1.267486
## [2,] 36.79734 -1.259690
## [3,] 36.77077 -1.290325
## [4,] 36.76877 -1.296051
## [5,] 36.79066 -1.258515
## [6,] 36.77899 -1.264575
```

---

# Get bounding box


```r
schools_sf %&gt;% 
  st_bbox() 
```

```
##      xmin      ymin      xmax      ymax 
## 36.691965 -1.374473 37.065336 -1.177316
```


# Spatial operations using multiple datasets

* `st_distance`: Calculate distances.
* `st_intersects`: Indicates whether simple features intersect.
* `st_intersection`: Cut one spatial object based on another.
* `st_difference`: Remove part of spatial object based on another.  
* `st_join`: Spatial join (ie, add attributes of one dataframe to another based on location). 

---

# Distances

For this example, we'll compute the distance between each school to a motorway.


```r
motor_sf &lt;- roads_sf %&gt;%
  filter(highway == "motorway")

# Matrix: distance of each school to each motorway
dist_mat &lt;- st_distance(schools_sf, motor_sf)

# Take minimun distance for each school
dist_mat %&gt;% apply(1, min) %&gt;% head()
```

```
## [1]   33.78464  155.32799 4006.16459 4662.68796  176.10524 1382.28513
```

---

# Distances

There are multiple ways to calculate distances!

* __Great circle:__ sf, by default, uses s2 to computer distance (in meters) when data has a geographic CRS
* __Great circle:__ Other formulas beyond s2, such as Haversine, Vincenty, and Karney’s method. See the [geosphere](https://cran.r-project.org/web/packages/geosphere/geosphere.pdf) and [geodist](https://cran.r-project.org/web/packages/geodist/geodist.pdf) packages. Vincenty is more precise than Haversine, and Karney's method is more precise than Vincenty's method. Greater precision comes with heavy computation. For more information, see [here](https://rspatial.org/raster/sphere/2-distance.html).
* __Projected:__ We can use a projected CRS, where units are in meters already.

---

# Distances

.pull-left[

```r
# s2
st_distance(schools_sf[1,], schools_sf[2,]) %&gt;% 
  as.numeric()
```

```
## [1] 1144.271
```

```r
# Nigeria-specific CRS
schools_utm_sf &lt;- st_transform(schools_sf, 32632)
st_distance(schools_utm_sf[1,], schools_utm_sf[2,]) %&gt;% 
  as.numeric()
```

```
## [1] 1290.671
```

```r
# World mercator
schools_merc_sf &lt;- st_transform(schools_sf, 3395)
st_distance(schools_merc_sf[1,], schools_merc_sf[2,]) %&gt;% 
  as.numeric()
```

```
## [1] 1141.436
```

]

.pull-right[

```r
# Haversine
distHaversine(
  p1 = schools_sf[1,] %&gt;% st_coordinates,
  p2 = schools_sf[2,] %&gt;% st_coordinates)
```

```
## [1] 1145.551
```

```r
# Vincenty's method
distVincentySphere(
  p1 = schools_sf[1,] %&gt;% st_coordinates,
  p2 = schools_sf[2,] %&gt;% st_coordinates)
```

```
## [1] 1145.551
```

```r
# Karney’s method 
distGeo(p1 = schools_sf[1,] %&gt;% st_coordinates,
        p2 = schools_sf[2,] %&gt;% st_coordinates)
```

```
## [1] 1141.16
```

]

---

# Intersects

For this example we'll determine which second administrative divisions intersects with a motorway.


```r
# Sparse matrix
st_intersects(city_sf, motor_sf) %&gt;% print()
```

```
## Sparse geometry binary predicate list of length 17, where the predicate
## was `intersects'
## first 10 elements:
##  1: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ...
##  2: (empty)
##  3: (empty)
##  4: 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, ...
##  5: (empty)
##  6: 30, 32, 33, 34, 35, 36, 37, 38, 39, 40, ...
##  7: (empty)
##  8: (empty)
##  9: (empty)
##  10: 42, 43, 45, 64
```

---

# Intersects

Take `max` (`FALSE` corresponds to 0 and `TRUE` corresponds to 1). So taking max will yeild if unit intersects with _any_ motorway


```r
# Matrix
st_intersects(city_sf, motor_sf, sparse = F) %&gt;% 
  apply(1, max) %&gt;%
  head()
```

```
## [1] 1 0 0 1 0 1
```

---

# Intersection

We have roads for the full city. Here, we want to create new roads object that __only includes__ roads in one unit.


```r
loc_sf &lt;- city_sf %&gt;%
  head(1)

roads_loc_sf &lt;- st_intersection(roads_sf, loc_sf)
```

```
## Warning: attribute variables are assumed to be spatially constant throughout all
## geometries
```

```r
ggplot() +
  geom_sf(data = roads_loc_sf)
```

&lt;img src="03-spatial-data-operations_files/figure-html/unnamed-chunk-24-1.png" width="40%" style="display: block; margin: auto;" /&gt;

---

# Difference

We have roads for all of the city. Here, we want to create new roads object that __excludes__ roads in one unit.


```r
roads_notloc_sf &lt;- st_difference(roads_sf, loc_sf)
```

```
## Warning: attribute variables are assumed to be spatially constant throughout all
## geometries
```

```r
ggplot() +
  geom_sf(data = loc_sf, fill = NA, color = "red") +
  geom_sf(data = roads_notloc_sf) 
```

&lt;img src="03-spatial-data-operations_files/figure-html/unnamed-chunk-25-1.png" width="40%" style="display: block; margin: auto;" /&gt;

---

# Overlay

Intersections and differencing are __overlay__ functions

.center[
![Overlay](img/overlay_examples.png)
]

---

# Spatial join

We have a dataset of schools. The school dataframe contains information such as the school name, but not on the administrative region it's in. To add data on the administrative region that the school is in, we'll perform a spatial join.

Check the variable names. No names of second administrative divison :(

```r
names(schools_sf)
```

```
## [1] "osm_id"   "name"     "amenity"  "geometry"
```

---

# Spatial join

Use `st_join` to add attributes from `city_sf` to `schools_sf`. `st_join` is similar to other join methods (eg, `left_join`); instead of joining on a varible, we join based on location.


```r
schools_city_sf &lt;- st_join(schools_sf, city_sf)

schools_city_sf %&gt;% 
  names() %&gt;% 
  print() %&gt;%
  tail(10)
```

```
##  [1] "osm_id"    "name"      "amenity"   "geometry"  "GID_2"     "GID_0"    
##  [7] "COUNTRY"   "GID_1"     "NAME_1"    "NL_NAME_1" "NAME_2"    "VARNAME_2"
## [13] "NL_NAME_2" "TYPE_2"    "ENGTYPE_2" "CC_2"      "HASC_2"
```

```
##  [1] "GID_1"     "NAME_1"    "NL_NAME_1" "NAME_2"    "VARNAME_2" "NL_NAME_2"
##  [7] "TYPE_2"    "ENGTYPE_2" "CC_2"      "HASC_2"
```


---

# Spatial join

.exercise[

**Exercise:** Make a static map using of administrative areas, where each administrative area polygon displays the number of schools.

]

--

.solution[
**Solution**: 

```r
## Dataframe of number of schools per NAME_2
n_school_df &lt;- schools_city_sf %&gt;%
  st_drop_geometry() %&gt;%
  group_by(NAME_2) %&gt;%
  summarise(n_school = n()) %&gt;%
  ungroup()

## Merge info with city_sf
city_sch_sf &lt;- city_sf %&gt;% left_join(n_school_df, by = "NAME_2")

## Map
p &lt;- ggplot() +
  geom_sf(data = city_sch_sf,
          aes(fill = n_school))
```

]

---

# Spatial join


```r
ggplot() +
  geom_sf(data = city_sch_sf,
          aes(fill = n_school)) +
  labs(fill = "N\nSchools") +
  scale_fill_distiller(palette = "YlOrRd") +
  theme_void()
```

&lt;img src="03-spatial-data-operations_files/figure-html/unnamed-chunk-29-1.png" width="65%" style="display: block; margin: auto;" /&gt;

---

# Resources

.large[
* [sf package cheatsheet](https://github.com/rstudio/cheatsheets/blob/main/sf.pdf)
* [Spatial Data Science with Applications in R](https://r-spatial.org/book/)
* [Geocomputation with R](https://r.geocompx.org/)
]

---

class: inverse, center, middle

# Thank you!

    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"ratio": "16:9",
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
